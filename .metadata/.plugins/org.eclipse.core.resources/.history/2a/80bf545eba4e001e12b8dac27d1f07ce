//import static org.junit.Assert.*;
//
//import java.nio.ByteBuffer;
//import student.TestCase;
//
//public class myHashTableTest {
//
//	public void testHashingCalculation() {
//	
//		MyHashTable test = new MyHashTable(1024);
//		assertEquals(1, test.calculateFirstHashing(1, 1024));
//		assertEquals(1, test.calculateSecondHashing(1, 2));
//	}
//	
//	public void testHashing() {
//		Handle handle = new Handle(-1, -1, -1);
//		MyHashTable test = new MyHashTable(1024);
//		Handle[] insertArr = new Handle[256];
//		//assertTrue(test.hashing(1, handle, insertArr, false));
////		assertEquals(38，insertArr[o].getKey()); 
////		assertEquals(1, test.calculateSecondHashing(1, 2));
////		assertEquals(handle，insertArr[o]);
//	}
//	
//	public void testInsert() {
////		Handle handle = new Handle(-1, -1, -1);
////		MyHashTable test = new MyHashTable(1024);
////		Handle[] insertArr = new Handle[256];
////		assertTrue(test.hashing(1, handle, insertArr, false));
////		assertEquals(1, test.calculateSecondHashing(1, 2));
////		assertEquals(1, test.calculateSecondHashing(1, 2));
//	}
//
//}



import static org.junit.Assert.assertTrue;

public class myHashTableTest {

    private MyHashTable yourObject;
    private Handle[] insertArr;
    
    void setUp() {
        // Initialize your object and insertArr before each test
        yourObject = new MyHashTable(1024);
        insertArr = new Handle[10]; // Adjust the array size as needed
    }

    void testHashingWithIgnoreLastElementIndex() {
        int key = 123;
        Handle handle = new Handle(-1, -1, -1);
        boolean ignoreLastElementIndex = true;

        boolean result = yourObject.hashing(key, handle, insertArr, ignoreLastElementIndex);

        assertTrue(result);
        // Add assertions here to verify the expected behavior
        // For example, check that insertArr has been updated correctly
        // and other conditions are met
    }

    @Test
    void testHashingWithoutIgnoreLastElementIndex() {
        int key = 456;
        Handle handle = new Handle(-1, -1, -1);
        boolean ignoreLastElementIndex = false;

        boolean result = yourObject.hashing(key, handle, insertArr, ignoreLastElementIndex);

        assertTrue(result);
        // Add assertions here to verify the expected behavior
        // For example, check that insertArr has been updated correctly
        // and other conditions are met
    }

    void testHashingWithCollision() {
        // Simulate a collision scenario
        int key1 = 123;
        int key2 = 456;
        Handle handle1 = new Handle(-1, -1, -1);
        Handle handle2 = new Handle(-1, -1, -1);
        boolean ignoreLastElementIndex = false;

        // Insert the first element
        assertTrue(yourObject.hashing(key1, handle1, insertArr, ignoreLastElementIndex));

        // Insert the second element with the same hash
        assertTrue(yourObject.hashing(key2, handle2, insertArr, ignoreLastElementIndex));

        // Add assertions here to verify the expected behavior
        // For example, check that insertArr has been updated correctly
        // and that both elements have been inserted properly
    }

    void testReHash() {
        // Test rehashing when lastElementIndex exceeds arrSize/2
        // Insert elements until rehashing is triggered
        int arrSize = insertArr.length;
        for (int i = 0; i < arrSize / 2; i++) {
            int key = i;
            Handle handle = new Handle(-1, -1, -1);
            boolean ignoreLastElementIndex = false;
            assertTrue(yourObject.hashing(key, handle, insertArr, ignoreLastElementIndex));
        }

        // Now, adding one more element should trigger rehashing
        int key = arrSize / 2;
        Handle handle = new Handle(-1, -1, -1);
        boolean ignoreLastElementIndex = false;
        assertTrue(yourObject.hashing(key, handle, insertArr, ignoreLastElementIndex));

        // Add assertions here to verify that rehashing has occurred correctly
        // and that the array size has doubled
    }

    // Add more test cases as needed to cover different scenarios and edge cases
}
